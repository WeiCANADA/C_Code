//
// Created by ThinkPad on 2021-06-03.
//隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型
//提升。
//整型提升的意义：
//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
//一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
//度。
//通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
//中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
//换为int或unsigned int，然后才能送入CPU去执行运算。

int main()
{
    char a, b, c;
    a = 3;
    //	//00000000000000000000000000000011
	//00000011 - a
    b = 127;
    //	//00000000000000000000000001111111
//	//01111111 - b
    c = a + b;

//	//a和b如何相加
//	//00000000000000000000000000000011
//	//00000000000000000000000001111111
//	//00000000000000000000000010000010
//	//
    printf("c = %d\n", c);
    //	//10000010-c
//	//11111111111111111111111110000010 - 补码
//	//11111111111111111111111110000001 - 反码
//	//10000000000000000000000001111110- 原码
//	//-126
    return 0;
}

